C51 COMPILER V9.00   MAIN                                                                  05/13/2016 08:43:12 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c COMPACT ROM(COMPACT) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          /**
   2          **      FINDBAKE MAIN C FILE
   3          **
   4          **      TODO:
   5          **               run program at the first       
   6          **
   7          **      @luodongseu     github.com/luodongseu    2016/5/6
   8          **/
   9          
  10          //
  11          // 模块接口实现说明：
  12          //                                       串口1  P30,P31：GPRS模块（接收和发送数据）
  13          //                                       串口2  P42：GPS模块    （接收GPS数据）
  14          //
  15          // 功能说明：
  16          //                      GPS串口不断接收数据，存储到本地GPSINFO变量中
  17          //                      GPRS定时将GPSINFO变量中的数据发送到服务器中     
  18          //
  19          
  20          /*************** 用户定义参数 *****************************/
  21          
  22          #define MAIN_Fosc       22118400L       //define main clock
  23          
  24          #define Baudrate1       38400           //define the baudrate, 如果使用BRT做波特率发生器,则波特率跟串口2一样
  25                                                                                  //12T mode: 600~115200 for 22.1184MHZ, 300~57600 for 11.0592MHZ
  26          
  27          #define Baudrate2       9600            //define the baudrate2,
  28                                                                                  //12T mode: 600~115200 for 22.1184MHZ, 300~57600 for 11.0592MHZ
  29          
  30          #define BUF_LENTH       128                     //定义串口接收缓冲长度
  31          
  32          #define UPLOAD_FREQ     10                      //计数频率，单位秒
  33          
  34          /**********************************************************/
  35          
  36          #include        <reg51.h>
  37          #include        "GPS.h"
  38          #include        "GPRS.h"
  39          
  40          //#define uchar unsigned char;
  41          
  42          
  43          sfr AUXR1 = 0xA2;
  44          sfr     AUXR  = 0x8E;
  45          sfr S2CON = 0x9A;       //12C5A60S2双串口系列
  46          sfr S2BUF = 0x9B;       //12C5A60S2双串口系列
  47          sfr IE2   = 0xAF;       //STC12C5A60S2系列
  48          sfr BRT   = 0x9C;
  49          
  50          //串口1读写
  51          uchar   GPRS_wr;                //写指针
  52          uchar   GPRS_rd;                //读指针
  53          uchar   xdata GPRS_Buffer[BUF_LENTH];//接收缓存：
  54          bit             B_TI;                   //中断标志位
C51 COMPILER V9.00   MAIN                                                                  05/13/2016 08:43:12 PAGE 2   

  55          uchar   GPRS_Listening; //启动成功后监听
  56          
  57          
  58          //串口2读写
  59          uchar   GPS_wr = 0;             //写指针
  60          uchar   GPS_rd = 0;             //读指针
  61          uchar   xdata GPS_Buffer[BUF_LENTH];//接收缓存  [0]表示写允许位 [1]表示读允许位
  62          unsigned int    gps_rev_start = 0;//接收标志
  63          
  64          
  65          uchar   count = 0;              //计数
  66          
  67          //请求数据18,43,57
  68          uchar   xdata   request[128] = "GET /?data=1&ccid=00000000000000000000&lon=0000.0000&lat=0000.0000 HTTP/1.1\
             -r\nHost:www.luodongseu.top\r\n\r\n\r\n";
  69          //定位失败时的请求19
  70          uchar   xdata   fail_request[128] = "GET /?data=-1_ccid=00000000000000000000 HTTP/1.1\r\nHost:www.luodongseu
             -.top\r\n\r\n\r\n";
  71          
  72          /****************** 编译器自动生成，用户请勿修改 ************************************/
  73          
  74          #define T1_TimerReload  (256 - MAIN_Fosc / 192 / Baudrate1)                     //Calculate the timer1 reload value     at 12T mo
             -de
  75          #define BRT_Reload              (256 - MAIN_Fosc / 12 / 16 / Baudrate2)         //Calculate BRT reload value
  76          
  77          #define TimeOut1                (28800 / (unsigned long)Baudrate1 + 2)
  78          #define TimeOut2                (28800 / (unsigned long)Baudrate2 + 2)
  79          
  80          #define TI2                             (S2CON & 0x02) != 0
  81          #define RI2                             (S2CON & 0x01) != 0
  82          #define CLR_TI2()               S2CON &= ~0x02
  83          #define CLR_RI2()               S2CON &= ~0x01
  84          
  85          /**********************************************************/
  86          
  87          
  88          //GPRS串口初始化
  89          void    GPRS_init(void)
  90          {
  91   1              TMOD = 0x20;    //定时器1工作在方式2  8位自动重装
  92   1              //PCON |= 0x80;         //UART0 Double Rate Enable
  93   1              SCON = 0x50;            //UART0 set as 10bit , UART0 RX enable
  94   1              //TMOD &= ~(1<<6);              //Timer1 Set as Timer, 12T
  95   1              //TMOD = (TMOD & ~0x30) | 0x20; //Timer1 set as 8 bits auto relaod
  96   1              TH1 = T1_TimerReload;           //Load the timer
  97   1              TL1 = TH1;
  98   1              TR1  = 1;
  99   1              ES  = 1;
 100   1              EA = 1;
 101   1      }                                                                                                        
 102          
 103          //GPS串口初始化
 104          void    GPS_init(void)
 105          {
 106   1              AUXR1 |= (1<<4);        //将UART2从P1口切换到 RXD2--P1.2切换到P4.2   TXD2---P1.3切换到P4.3
 107   1              AUXR |=  (1 << 3);              //串口2波特率加倍
 108   1              S2CON  = (S2CON & 0x3f) | (1<<6);       //串口2模式1，8位UART，(2^S2SMOD / 32) * BRT溢出率
 109   1              S2CON |= 1 << 4;                //允许串2接收
 110   1              //S2CON = 0x50;   //串口2工作在方式1  10位异步收发 S2REN=1允许接收
 111   1      
 112   1              AUXR |=  1 << 4;        //baudrate use BRT
 113   1              BRT = BRT_Reload;
C51 COMPILER V9.00   MAIN                                                                  05/13/2016 08:43:12 PAGE 3   

 114   1      
 115   1              IE2 |=  1;                      //允许串口2中断
 116   1      }
 117          
 118          
 119          ////GPRS口发送数据
 120          //void  GPRS_TxByte(uchar dat)
 121          //{
 122          //      SBUF = dat;             //将接收的数据发送回去
 123          //      while(TI == 0); //检查发送中断标志位
 124          //      TI = 0;                 //令发送中断标志位为0（软件清零）
 125          //}
 126          //
 127          ////GPRS口发送一串字符串
 128          //void GPRS_TxString(uchar code *puts)          
 129          //{
 130          //    for (; *puts != 0;        puts++)  GPRS_TxByte(*puts);    //遇到停止符0结束
 131          //}
 132          
 133          //GPS输出口发送数据 用于调试数据
 134          void Test_TxByte(uchar c)
 135          {
 136   1              S2BUF = c;
 137   1              while(TI2);
 138   1              CLR_TI2();
 139   1      }
 140          
 141          //GPS口发送一串字符串
 142          void Test_TxString(uchar *puts)         
 143          {
 144   1          for (; *puts != '\0';       puts++)  GPS_TxByte(*puts);     //遇到停止符0结束
 145   1      }
 146          
 147          //清除GPRS接收数据缓存
 148          void clear_gprs_rev_buf()
 149          {
 150   1              uchar index=0;
 151   1               
 152   1              for(index = 0 ; index < BUF_LENTH ; index++)
 153   1              {
 154   2                      GPRS_Buffer[index]='\0';
 155   2              }
 156   1      
 157   1              GPRS_Buffer[0] = 2;             //允许写位
 158   1              GPRS_Buffer[1] = 2;             //允许读位
 159   1              GPRS_wr = 0;                    //写指针位
 160   1      }
 161          
 162          //清除GPS接收数据缓存
 163          void clear_gps_rev_buf()
 164          {
 165   1              uchar index=0;
 166   1               
 167   1              for(index = 0 ; index < BUF_LENTH ; index++)
 168   1              {
 169   2                      GPS_Buffer[index]='\0';
 170   2              }
 171   1      
 172   1              GPS_Buffer[0] = 2;              //允许写位
 173   1              GPS_Buffer[1] = 2;              //允许读位
 174   1              GPS_wr = 0;                     //写指针位
 175   1              gps_rev_start = 0;      
C51 COMPILER V9.00   MAIN                                                                  05/13/2016 08:43:12 PAGE 4   

 176   1      }
 177          
 178          /**
 179          串口1中断响应
 180          *************
 181          接收GPRS数据
 182          *************
 183          对应--GPRS模块
 184          *************
 185          **/
 186          void    GPRS_RCV (void) interrupt 4
 187          {
 188   1              uchar ch;
 189   1              if(RI)
 190   1              {
 191   2                      //EA = 0;       //暂停中断
 192   2                      RI = 0; //复位
 193   2      
 194   2                      
 195   2                      ch = SBUF;
 196   2      
 197   2                      //GPS_TxString("gprs rev");
 198   2                      if(GPRS_Listening != 1)    //GPRS在初始化中,将中断数据返回给GPRS
 199   2                      {
 200   3                              setRevBuf(ch);  
 201   3                      }
 202   2                      else
 203   2                      {
 204   3                              if(ch == '{')  // 服务器返回有效数据起始位为'{'
 205   3                              {
 206   4                                      GPRS_Buffer[0] = 1;     //数据缓存允许位置1，表示允许接收
 207   4                                      GPRS_Buffer[1] = 2;     //数据缓存可读位置2，表示数据不可读
 208   4                                      GPRS_wr = 1;            
 209   4                              }
 210   3                              else if (GPRS_Buffer[0] == 1 && ch == '}') //服务器返回有效数据结束位为'}'
 211   3                              {
 212   4                                      GPRS_Buffer[1] = 1;             //数据缓存可读位置1，表示数据可读
 213   4                                      GPRS_Buffer[0] = 2;             //数据缓存允许位置2，表示不允许接收             
 214   4                              }
 215   3                              else if (GPRS_Buffer[0] == 1)
 216   3                              {
 217   4                                      if(++GPRS_wr < BUF_LENTH -1)            //防止数据溢出
 218   4                                      {
 219   5                                              GPRS_Buffer[GPRS_wr] = ch;
 220   5                                      }
 221   4                                      else
 222   4                                      {
 223   5                                              clear_gprs_rev_buf();
 224   5                                      }
 225   4                                      
 226   4                              }
 227   3                              else    //无效数据
 228   3                              {
 229   4                                      clear_gprs_rev_buf();
 230   4                              }       
 231   3                      }
 232   2      
 233   2                      //EA = 1;       //打开中断
 234   2              }
 235   1      }
 236          
 237          uchar a[5] = "abc\n";//测试的数据
C51 COMPILER V9.00   MAIN                                                                  05/13/2016 08:43:12 PAGE 5   

 238          
 239          /**
 240          串口1中断响应
 241          *************
 242          接收GPS数据
 243          *************
 244          对应--GPS模块 只解析GPRMC数据
 245          *************
 246          **/
 247          void GPS_RCV (void) interrupt 8
 248          {
 249   1              uchar ch;
 250   1              
 251   1              if(!RI2)
 252   1              {
 253   2                      return;
 254   2              }
 255   1      
 256   1              if(GPRS_Listening != 1 ) //只有当计数为最大值时，且处于监听状态才可以读取数据
 257   1              {
 258   2                      CLR_RI2();
 259   2                      return;
 260   2              }
 261   1      
 262   1              ch=S2BUF;
 263   1      
 264   1              if (gps_rev_start == 0 && ch == '$')  //如果收到字符'$' 标志为1
 265   1              {
 266   2                      gps_rev_start = 1;
 267   2              }       
 268   1              else if (gps_rev_start == 1 && ch == 'G') //如果 标志位为1,收到字符'G'，判断第2位
 269   1              {
 270   2                      gps_rev_start = 2;                      
 271   2              }
 272   1              else if (gps_rev_start == 2 && ch == 'P')  //如果 标志位为2,收到字符'P'，判断第3位
 273   1              {
 274   2                      gps_rev_start = 3;
 275   2              }
 276   1              else if (gps_rev_start == 3 && ch == 'R')  //如果 标志位为3,收到字符'R'，判断第4位
 277   1              {
 278   2                      gps_rev_start = 4;
 279   2              }
 280   1              else if (gps_rev_start == 4 && ch == 'M')  //如果 标志位为4,收到字符'M'，判断第5位
 281   1              {
 282   2                      gps_rev_start = 5;
 283   2              }
 284   1              else if (gps_rev_start == 5 && ch == 'C')  //如果 标志位为5,收到字符'C'，判断第6位
 285   1              {
 286   2                      gps_rev_start = 6;
 287   2              }
 288   1              else if (gps_rev_start == 6 && ch == ',')  //如果 标志位为6,收到字符','，开始接收数据
 289   1              {
 290   2                      gps_rev_start = 7;
 291   2                      GPS_wr = 2;
 292   2                      GPS_Buffer[1]=2;        //不允许读
 293   2                      GPS_Buffer[0]=1;        //允许写
 294   2              }
 295   1              else if(gps_rev_start >= 1 && gps_rev_start < 7)
 296   1              {
 297   2                      gps_rev_start = 0;      
 298   2              }
 299   1      
C51 COMPILER V9.00   MAIN                                                                  05/13/2016 08:43:12 PAGE 6   

 300   1              if(gps_rev_start == 7 && GPS_Buffer[1] != 1)
 301   1              {
 302   2      
 303   2                      if (ch == '\n')     //如果接收到换行
 304   2                      {
 305   3                              count = count + 1;
 306   3                              gps_rev_start = 0;      //只要遇到换行符，必须重新匹配开头
 307   3                              //Test_TxString("GO END\n");
 308   3                              if(count == UPLOAD_FREQ + 1) // 当计数等于count+1 的时候才记录数据,让等于10的时候记录数据
 309   3                              {
 310   4                                      //Test_TxString("GOT A END\n");         
 311   4                                      GPS_Buffer[0]=2; //不允许写
 312   4                                      GPS_Buffer[1]=1; //允许读 
 313   4                                      count = 0;              //重置计数器
 314   4                                      delay(1000);
 315   4                              }                       
 316   3                      }
 317   2                      else //$GPRMC，与换行符中间的数据
 318   2                      {                               
 319   3                              if(count == UPLOAD_FREQ && GPS_Buffer[0] == 1)//可写
 320   3                              {
 321   4                                      GPS_Buffer[GPS_wr] = ch;  //字符存到数组中
 322   4                                      GPS_wr = GPS_wr + 1;
 323   4                              }                               
 324   3                      }
 325   2                              
 326   2              }
 327   1              CLR_RI2();
 328   1      }
 329          
 330          
 331          //入口主函数
 332          void main(){
 333   1              uchar index = 0;
 334   1              uchar*  ccid = getCcid();
 335   1              GPRS_wr = 0;
 336   1              GPS_wr = 0;
 337   1              GPRS_Listening = 0;
 338   1              
 339   1              clear_gps_rev_buf();
 340   1              clear_gprs_rev_buf();
 341   1              
 342   1              GPS_init();
 343   1              GPRS_init();
 344   1      
 345   1              Test_TxString("main____\n");
 346   1              gprs_start();                                   //启动GPRS初始化功能
 347   1      
 348   1              Test_TxString("main start listenning\n");
 349   1              
 350   1              //填充request中的CCID号
 351   1              
 352   1              
 353   1              for(index = 0;index < 20;index++)
 354   1              {
 355   2                      request[18+index] = ccid[index];
 356   2                      fail_request[19+index] = ccid[index];
 357   2              }
 358   1              
 359   1              GPRS_Listening = 1;                             //开始监听网络传输数据
 360   1      
 361   1              //EA = 0;
C51 COMPILER V9.00   MAIN                                                                  05/13/2016 08:43:12 PAGE 7   

 362   1              while(1)
 363   1              {
 364   2                      
 365   2                      //除了GPS数据
 366   2                      if(GPS_Buffer[1] == 1)  //GPS数据可读时操作
 367   2                      {
 368   3                              Test_TxString("Send GPS Buffer:");
 369   3                              Test_TxString(&GPS_Buffer[2]);
 370   3                              Test_TxString("\n");
 371   3                              /**
 372   3                              **[13]-定位结果状态V/A
 373   3                              **[43-51]-纬度 ddmm.mmmm
 374   3                              **[57-65]-经度 ddmm.mmmm
 375   3                              **/
 376   3                              if(GPS_Buffer[13] != 'A')
 377   3                              {
 378   4                                      //定位失败,发送-1               
 379   4                                      sendData(fail_request);
 380   4                              }
 381   3                              else
 382   3                              {
 383   4                                      //填充真实坐标数据
 384   4                                      //纬度
 385   4                                      request[43]=GPS_Buffer[15];                                     
 386   4                                      request[44]=GPS_Buffer[16];
 387   4                                      request[45]=GPS_Buffer[17];
 388   4                                      request[46]=GPS_Buffer[18];
 389   4                                      //request[47]=GPS_Buffer[19];//小数点
 390   4                                      request[48]=GPS_Buffer[20];
 391   4                                      request[49]=GPS_Buffer[21];
 392   4                                      request[50]=GPS_Buffer[22];
 393   4                                      request[51]=GPS_Buffer[23];
 394   4                                      //经度
 395   4                                      request[57]=GPS_Buffer[27];
 396   4                                      request[58]=GPS_Buffer[28];
 397   4                                      request[59]=GPS_Buffer[29];
 398   4                                      request[60]=GPS_Buffer[30];
 399   4                                      //request[61]=GPS_Buffer[31];//小数点
 400   4                                      request[62]=GPS_Buffer[32];
 401   4                                      request[63]=GPS_Buffer[33];
 402   4                                      request[64]=GPS_Buffer[34];
 403   4                                      request[65]=GPS_Buffer[35];
 404   4      
 405   4                                      sendData(request);
 406   4                              }
 407   3                              clear_gps_rev_buf();
 408   3                      }
 409   2                      //处理GPRS接收的数据
 410   2                      if(GPRS_Buffer[1] == 1)  //GPRS收到服务器返回的数据
 411   2                      {
 412   3                              Test_TxString("Got GPRS Buffer:");
 413   3                              Test_TxString(&GPRS_Buffer[2]);
 414   3                              Test_TxString("\n");
 415   3                              clear_gprs_rev_buf();
 416   3                      }
 417   2                      //delay(2000);
 418   2              }
 419   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1068    ----
C51 COMPILER V9.00   MAIN                                                                  05/13/2016 08:43:12 PAGE 8   

   CONSTANT SIZE    =     69    ----
   XDATA SIZE       =    512    ----
   PDATA SIZE       =     13       8
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
