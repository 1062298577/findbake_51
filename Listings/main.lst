C51 COMPILER V9.00   MAIN                                                                  05/15/2016 20:09:59 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c COMPACT ROM(COMPACT) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          /**
   2          **      FINDBAKE MAIN C FILE
   3          **
   4          **      TODO:
   5          **               run program at the first       
   6          **
   7          **      @luodongseu     github.com/luodongseu    2016/5/6
   8          **/
   9          
  10          //
  11          // 模块接口实现说明：
  12          //                                       串口1  P30,P31：GPRS模块（接收和发送数据）
  13          //                                       串口2  P42：GPS模块    （接收GPS数据）
  14          //
  15          // 功能说明：
  16          //                      GPS串口不断接收数据，存储到本地GPSINFO变量中
  17          //                      GPRS定时将GPSINFO变量中的数据发送到服务器中     
  18          //
  19          
  20          /*************** 用户定义参数 *****************************/
  21          
  22          #define MAIN_Fosc       22118400L       //define main clock
  23          
  24          #define Baudrate1       38400           //define the baudrate, 如果使用BRT做波特率发生器,则波特率跟串口2一样
  25                                                                                  //12T mode: 600~115200 for 22.1184MHZ, 300~57600 for 11.0592MHZ
  26          
  27          #define Baudrate2       9600            //define the baudrate2,
  28                                                                                  //12T mode: 600~115200 for 22.1184MHZ, 300~57600 for 11.0592MHZ
  29          
  30          #define BUF_LENTH       128                     //定义串口接收缓冲长度
  31          
  32          
  33          
  34          /**********************************************************/
  35          
  36          #include        <reg51.h>
  37          #include        "GPS.h"
  38          #include        "GPRS.h"
  39          
  40          //#define uchar unsigned char;
  41          
  42          sbit BEEP = P1^0;       //蜂鸣器
  43          
  44          sfr AUXR1 = 0xA2;
  45          sfr     AUXR  = 0x8E;
  46          sfr S2CON = 0x9A;       //12C5A60S2双串口系列
  47          sfr S2BUF = 0x9B;       //12C5A60S2双串口系列
  48          sfr IE2   = 0xAF;       //STC12C5A60S2系列
  49          sfr BRT   = 0x9C;
  50          
  51          //串口1读写
  52          uchar   GPRS_wr;                //写指针
  53          uchar   GPRS_rd;                //读指针
  54          uchar   xdata   GPRS_Buffer[BUF_LENTH];//接收缓存：
C51 COMPILER V9.00   MAIN                                                                  05/15/2016 20:09:59 PAGE 2   

  55          bit             B_TI;                   //中断标志位
  56          bit             GPRS_Listening; //启动成功后监听
  57          bit             GPRS_SEND;              //发送标志
  58          
  59          
  60          //串口2读写
  61          uchar   GPS_wr = 0;             //写指针
  62          uchar   GPS_rd = 0;             //读指针
  63          uchar   xdata   GPS_Buffer[BUF_LENTH];//接收缓存        [0]表示写允许位 [1]表示读允许位
  64          unsigned int    gps_rev_start = 0;//接收标志
  65          
  66          
  67          bit     voice = 0;              //蜂鸣器
  68          
  69          uchar   UPLOAD_FREQ     = 30;//计数频率，单位秒
  70          uchar   count = 0;              //计数
  71          
  72          //请求数据18,43,57
  73          uchar   xdata   request[128] = "GET /?data=1&ccid=00000000000000000000&lon=0000.0000&lat=0000.0000 HTTP/1.1\
             -r\n\r\n\r\n";
  74          //定位失败时的请求19
  75          uchar   xdata   fail_request[128] = "GET /?data=-1&ccid=00000000000000000000 HTTP/1.1\r\n\r\n\r\n";
  76          
  77          /****************** 编译器自动生成，用户请勿修改 ************************************/
  78          
  79          #define T1_TimerReload  (256 - MAIN_Fosc / 192 / Baudrate1)                     //Calculate the timer1 reload value     at 12T mo
             -de
  80          #define BRT_Reload              (256 - MAIN_Fosc / 12 / 16 / Baudrate2)         //Calculate BRT reload value
  81          
  82          #define TimeOut1                (28800 / (unsigned long)Baudrate1 + 2)
  83          #define TimeOut2                (28800 / (unsigned long)Baudrate2 + 2)
  84          
  85          #define TI2                             (S2CON & 0x02) != 0
  86          #define RI2                             (S2CON & 0x01) != 0
  87          #define CLR_TI2()               S2CON &= ~0x02
  88          #define CLR_RI2()               S2CON &= ~0x01
  89          
  90          /**********************************************************/
  91          /*********************************************************
  92           500us延时函数
  93           晶振：22.1184MHz
  94          *********************************************************/
  95          void delay500us(void)
  96          {
  97   1              uchar  i,j;
  98   1              for(j=500;j>0;j--)
  99   1                      for(i=81;i>0;i--);
 100   1      }
 101          
 102          //GPRS串口初始化
 103          void    GPRS_init(void)
 104          {
 105   1              TMOD = 0x20;    //定时器1工作在方式2  8位自动重装
 106   1              //PCON |= 0x80;         //UART0 Double Rate Enable
 107   1              SCON = 0x50;            //UART0 set as 10bit , UART0 RX enable
 108   1              //TMOD &= ~(1<<6);              //Timer1 Set as Timer, 12T
 109   1              //TMOD = (TMOD & ~0x30) | 0x20; //Timer1 set as 8 bits auto relaod
 110   1              TH1 = T1_TimerReload;           //Load the timer
 111   1              TL1 = TH1;
 112   1              TR1  = 1;
 113   1              ES  = 1;
 114   1              EA = 1;
C51 COMPILER V9.00   MAIN                                                                  05/15/2016 20:09:59 PAGE 3   

 115   1      }                                                                                                        
 116          
 117          //GPS串口初始化
 118          void    GPS_init(void)
 119          {
 120   1              AUXR1 |= (1<<4);        //将UART2从P1口切换到 RXD2--P1.2切换到P4.2   TXD2---P1.3切换到P4.3
 121   1              AUXR |=  (1 << 3);              //串口2波特率加倍
 122   1              S2CON  = (S2CON & 0x3f) | (1<<6);       //串口2模式1，8位UART，(2^S2SMOD / 32) * BRT溢出率
 123   1              S2CON |= 1 << 4;                //允许串2接收
 124   1              //S2CON = 0x50;   //串口2工作在方式1  10位异步收发 S2REN=1允许接收
 125   1      
 126   1              AUXR |=  1 << 4;        //baudrate use BRT
 127   1              BRT = BRT_Reload;
 128   1      
 129   1              IE2 |=  1;                      //允许串口2中断
 130   1      }
 131          
 132          
 133          ////GPRS口发送数据
 134          //void  GPRS_TxByte(uchar dat)
 135          //{
 136          //      SBUF = dat;             //将接收的数据发送回去
 137          //      while(TI == 0); //检查发送中断标志位
 138          //      TI = 0;                 //令发送中断标志位为0（软件清零）
 139          //}
 140          //
 141          ////GPRS口发送一串字符串
 142          //void GPRS_TxString(uchar code *puts)          
 143          //{
 144          //    for (; *puts != 0;        puts++)  GPRS_TxByte(*puts);    //遇到停止符0结束
 145          //}
 146          
 147          //GPS输出口发送数据 用于调试数据
 148          void Test_TxByte(uchar c)
 149          {
 150   1              S2BUF = c;
 151   1              while(TI2);
 152   1              CLR_TI2();
 153   1      }
 154          
 155          //GPS口发送一串字符串
 156          void Test_TxString(uchar *puts)         
 157          {
 158   1          for (; *puts != '\0';       puts++)  GPS_TxByte(*puts);     //遇到停止符0结束
 159   1      }
 160          
 161          //清除GPRS接收数据缓存
 162          void clear_gprs_rev_buf()
 163          {
 164   1              uchar index=0;
 165   1               
 166   1              for(index = 0 ; index < BUF_LENTH ; index++)
 167   1              {
 168   2                      GPRS_Buffer[index]='0';
 169   2              }
 170   1              GPRS_Buffer[BUF_LENTH-1] = '\0';
 171   1              GPRS_Buffer[0] = '0';           //允许写位
 172   1              GPRS_Buffer[1] = '0';           //允许读位
 173   1              GPRS_wr = 0;                    //写指针位
 174   1      }
 175          
 176          //清除GPS接收数据缓存
C51 COMPILER V9.00   MAIN                                                                  05/15/2016 20:09:59 PAGE 4   

 177          void clear_gps_rev_buf()
 178          {
 179   1              uchar index=0;
 180   1               
 181   1              for(index = 0 ; index < BUF_LENTH ; index++)
 182   1              {
 183   2                      GPS_Buffer[index]='\0';
 184   2              }
 185   1      
 186   1              GPS_Buffer[0] = 2;              //允许写位
 187   1              GPS_Buffer[1] = 2;              //允许读位
 188   1              GPS_wr = 0;                     //写指针位
 189   1              gps_rev_start = 0;      
 190   1      }
 191          uchar a[5] = "abc\n";//测试的数据
 192          /**
 193          串口1中断响应
 194          *************
 195          接收GPRS数据
 196          *************
 197          对应--GPRS模块
 198          *************
 199          **/
 200          void    GPRS_RCV (void) interrupt 4
 201          {
 202   1              uchar ch;
 203   1              if(RI)
 204   1              {
 205   2                      
 206   2                      //EA = 0;       //暂停中断
 207   2                      RI = 0; //复位
 208   2                      BEEP = 1;       //蜂鸣器暂停
 209   2      
 210   2                      ch = SBUF;
 211   2      
 212   2                      if(!GPRS_Listening)       //GPRS在初始化中,将中断数据返回给GPRS  
 213   2                      {
 214   3                              setRevBuf(ch);  
 215   3                      }
 216   2                      else
 217   2                      {
 218   3                              if('{'==ch)     // 服务器返回有效数据起始位为'{'
 219   3                              {
 220   4                                      clear_gprs_rev_buf();
 221   4                                      GPRS_Buffer[0] = '1';   //数据缓存允许位置1，表示允许接收
 222   4                                      GPRS_Buffer[1] = '0';   //数据缓存可读位置0，表示数据不可读
 223   4                                      GPRS_wr = 2;
 224   4                                      //      GPRS_SEND = 0;                  
 225   4                              }
 226   3                              else if(GPRS_Buffer[0]=='1' && ch=='}') //服务器返回有效数据结束位为'}'
 227   3                              {
 228   4                                      GPRS_Buffer[1] = '1';           //数据缓存可读位置1，表示数据可读
 229   4                                      GPRS_Buffer[0] = '0';           //数据缓存允许位置2，表示不允许接收             
 230   4                              }                                          
 231   3                              else if(GPRS_Buffer[0]=='1')
 232   3                              {
 233   4                                      if(GPRS_wr != BUF_LENTH)                //防止数据溢出
 234   4                                      {
 235   5                                              GPRS_Buffer[GPRS_wr] = ch;
 236   5                                              
 237   5                                              GPRS_wr = 1 + GPRS_wr;;
 238   5                                      }
C51 COMPILER V9.00   MAIN                                                                  05/15/2016 20:09:59 PAGE 5   

 239   4                                      else
 240   4                                      {
 241   5                                              clear_gprs_rev_buf();
 242   5                                      }
 243   4      //                              Test_TxString("Got GPRS Buffer:");
 244   4      //                              Test_TxString(&GPRS_Buffer[3]);
 245   4      //                              Test_TxString("\n");    
 246   4                              }
 247   3                              else if(GPRS_Buffer[1]=='0')    //无效数据
 248   3                              {
 249   4                                      //处理ERROR情况
 250   4                                      clear_gprs_rev_buf();
 251   4                              }
 252   3                              
 253   3                              if(GPRS_Buffer[0]=='0' && GPRS_SEND == 1)  //发送数据时,由于设备初始化，因此需要回设接收的数据   
 254   3                              {
 255   4                                      setRevBuf(ch);
 256   4                              }
 257   3              
 258   3                      }
 259   2      
 260   2                      //EA = 1;       //打开中断
 261   2              }
 262   1      }
 263          
 264          
 265          
 266          /**
 267          串口1中断响应
 268          *************
 269          接收GPS数据
 270          *************
 271          对应--GPS模块 只解析GPRMC数据
 272          *************
 273          **/
 274          void GPS_RCV (void) interrupt 8
 275          {
 276   1              uchar ch;
 277   1              
 278   1              if(!RI2)
 279   1              {
 280   2                      return;
 281   2              }
 282   1      
 283   1              if(GPRS_Listening != 1 ) //只有当计数为最大值时，且处于监听状态才可以读取数据
 284   1              {
 285   2                      CLR_RI2();
 286   2                      return;
 287   2              }
 288   1      
 289   1              ch=S2BUF;
 290   1              BEEP = 1;       //蜂鸣器暂停
 291   1      
 292   1              if (gps_rev_start == 0 && ch == '$')  //如果收到字符'$' 标志为1
 293   1              {
 294   2                      gps_rev_start = 1;
 295   2              }       
 296   1              else if (gps_rev_start == 1 && ch == 'G') //如果 标志位为1,收到字符'G'，判断第2位
 297   1              {
 298   2                      gps_rev_start = 2;                      
 299   2              }
 300   1              else if (gps_rev_start == 2 && ch == 'P')  //如果 标志位为2,收到字符'P'，判断第3位
C51 COMPILER V9.00   MAIN                                                                  05/15/2016 20:09:59 PAGE 6   

 301   1              {
 302   2                      gps_rev_start = 3;
 303   2              }
 304   1              else if (gps_rev_start == 3 && ch == 'R')  //如果 标志位为3,收到字符'R'，判断第4位
 305   1              {
 306   2                      gps_rev_start = 4;
 307   2              }
 308   1              else if (gps_rev_start == 4 && ch == 'M')  //如果 标志位为4,收到字符'M'，判断第5位
 309   1              {
 310   2                      gps_rev_start = 5;
 311   2              }
 312   1              else if (gps_rev_start == 5 && ch == 'C')  //如果 标志位为5,收到字符'C'，判断第6位
 313   1              {
 314   2                      gps_rev_start = 6;
 315   2              }
 316   1              else if (gps_rev_start == 6 && ch == ',')  //如果 标志位为6,收到字符','，开始接收数据
 317   1              {
 318   2                      gps_rev_start = 7;
 319   2                      GPS_wr = 2;
 320   2                      GPS_Buffer[1]=2;        //不允许读
 321   2                      GPS_Buffer[0]=1;        //允许写
 322   2              }
 323   1              else if(gps_rev_start >= 1 && gps_rev_start < 7)
 324   1              {
 325   2                      gps_rev_start = 0;      
 326   2              }
 327   1      
 328   1              if(gps_rev_start == 7 && GPS_Buffer[1] != 1)
 329   1              {
 330   2      
 331   2                      if (ch == '\n')     //如果接收到换行
 332   2                      {
 333   3                              count = count + 1;
 334   3                              gps_rev_start = 0;      //只要遇到换行符，必须重新匹配开头
 335   3                              //Test_TxString("GO END\n");
 336   3                              if(count >= UPLOAD_FREQ + 1) // 当计数等于count+1 的时候才记录数据,让等于10的时候记录数据
 337   3                              {
 338   4                                      //Test_TxString("GOT A END\n");         
 339   4                                      GPS_Buffer[0]=2; //不允许写
 340   4                                      GPS_Buffer[1]=1; //允许读 
 341   4                                      count = 0;              //重置计数器
 342   4                                      delay(1000);
 343   4                              }                       
 344   3                      }
 345   2                      else //$GPRMC，与换行符中间的数据
 346   2                      {                               
 347   3                              if(count >= UPLOAD_FREQ && GPS_Buffer[0] == 1)//可写
 348   3                              {
 349   4                                      GPS_Buffer[GPS_wr] = ch;  //字符存到数组中
 350   4                                      GPS_wr = GPS_wr + 1;
 351   4                              }                               
 352   3                      }
 353   2                              
 354   2              }
 355   1              CLR_RI2();
 356   1      }
 357          
 358          
 359          //入口主函数
 360          void main(){
 361   1              uchar index = 0;
 362   1              uchar*  ccid = getCcid();
C51 COMPILER V9.00   MAIN                                                                  05/15/2016 20:09:59 PAGE 7   

 363   1              uchar fmq = 0;
 364   1              uchar orderIndex = 0;
 365   1      
 366   1              GPRS_wr = 0;
 367   1              GPS_wr = 0;
 368   1              GPRS_Listening = 0;
 369   1              GPRS_SEND = 0;
 370   1              
 371   1              clear_gps_rev_buf();
 372   1              clear_gprs_rev_buf();
 373   1              
 374   1              GPS_init();
 375   1              GPRS_init();
 376   1      
 377   1              Test_TxString("main____\n");
 378   1              gprs_start();                                   //启动GPRS初始化功能
 379   1      
 380   1              Test_TxString("main start listenning\n");
 381   1              
 382   1              //填充request中的CCID号
 383   1              
 384   1              
 385   1              for(index = 0;index < 20;index++)
 386   1              {
 387   2                      request[18+index] = ccid[index];
 388   2                      fail_request[19+index] = ccid[index];
 389   2              }
 390   1              
 391   1              GPRS_Listening = 1;                             //开始监听网络传输数据
 392   1      
 393   1              //EA = 0;
 394   1              while(1)
 395   1              {       
 396   2                      if(GPS_Buffer[1] == 1)  //GPS数据可读时操作
 397   2                      {
 398   3                              //EA = 0;
 399   3                              Test_TxString("Send GPS Buffer:");
 400   3                              Test_TxString(&GPS_Buffer[2]);
 401   3                              Test_TxString("\n");
 402   3                              /**
 403   3                              **[13]-定位结果状态V/A
 404   3                              **[43-51]-纬度 ddmm.mmmm
 405   3                              **[57-65]-经度 ddmm.mmmm
 406   3                              **/
 407   3                              if(GPS_Buffer[13] != 'A')
 408   3                              {
 409   4                                      //定位失败,发送-1
 410   4                                      Test_TxString(fail_request);
 411   4                                      GPRS_SEND = 1;
 412   4                                      //EA = 1;               
 413   4                                      sendData(fail_request);
 414   4                                      GPRS_SEND = 0;
 415   4                              }
 416   3                              else
 417   3                              {
 418   4                                      //填充真实坐标数据
 419   4                                      //纬度
 420   4                                      request[43]=GPS_Buffer[15];                                     
 421   4                                      request[44]=GPS_Buffer[16];
 422   4                                      request[45]=GPS_Buffer[17];
 423   4                                      request[46]=GPS_Buffer[18];
 424   4                                      //request[47]=GPS_Buffer[19];//小数点
C51 COMPILER V9.00   MAIN                                                                  05/15/2016 20:09:59 PAGE 8   

 425   4                                      request[48]=GPS_Buffer[20];
 426   4                                      request[49]=GPS_Buffer[21];
 427   4                                      request[50]=GPS_Buffer[22];
 428   4                                      request[51]=GPS_Buffer[23];
 429   4                                      //经度
 430   4                                      request[57]=GPS_Buffer[27];
 431   4                                      request[58]=GPS_Buffer[28];
 432   4                                      request[59]=GPS_Buffer[29];
 433   4                                      request[60]=GPS_Buffer[30];
 434   4                                      //request[61]=GPS_Buffer[31];//小数点
 435   4                                      request[62]=GPS_Buffer[32];
 436   4                                      request[63]=GPS_Buffer[33];
 437   4                                      request[64]=GPS_Buffer[34];
 438   4                                      request[65]=GPS_Buffer[35];
 439   4      
 440   4                                      GPRS_SEND = 1;
 441   4                                      //EA = 1;
 442   4                                      sendData(request);
 443   4                                      GPRS_SEND = 0;
 444   4                              }
 445   3                              clear_gps_rev_buf();
 446   3                              
 447   3                      }
 448   2                      
 449   2                      
 450   2                      Test_TxString("Got GPRS Buffer2:");
 451   2                      Test_TxString(GPRS_Buffer);
 452   2                      Test_TxString("\n");
 453   2      
 454   2                      if(GPRS_Buffer[1]=='1')  //处理GPRS接收的数据 //GPRS收到服务器返回的数据
 455   2                      {
 456   3                              EA = 0;
 457   3                              Test_TxString("Got GPRS Buffer:");
 458   3                              Test_TxString(&GPRS_Buffer[2]);
 459   3                              Test_TxString("\n");
 460   3      
 461   3                              //TODO 处理接收到的数据
 462   3                              if(GPRS_Buffer[2]=='2' && GPRS_Buffer[3]=='0' && GPRS_Buffer[4]=='1')   //如果返回了指令
 463   3                              {
 464   4                                      //提取声音指令
 465   4                                      for(orderIndex=6;orderIndex<BUF_LENTH;orderIndex++)
 466   4                                      {
 467   5                                              if(GPRS_Buffer[orderIndex]=='\0')
 468   5                                              {
 469   6                                                      break;
 470   6                                              }
 471   5                                              if(GPRS_Buffer[orderIndex]=='S' && GPRS_Buffer[orderIndex+2] != '\0') //如果存在S_X指令
 472   5                                              {
 473   6                                                      if(GPRS_Buffer[orderIndex+2] == 'O')     //打开指令
 474   6                                                      {
 475   7                                                              voice = 1;
 476   7                                                              //break;
 477   7                                                      }
 478   6                                                      else if(GPRS_Buffer[orderIndex+2] == 'C')        //关闭指令
 479   6                                                      {
 480   7                                                              voice = 0;
 481   7                                                              //break;
 482   7                                                      }
 483   6                                              }
 484   5      
 485   5                                              if(GPRS_Buffer[orderIndex]=='F' && GPRS_Buffer[orderIndex+2] != '\0') //如果存在F_X指令
 486   5                                              {
C51 COMPILER V9.00   MAIN                                                                  05/15/2016 20:09:59 PAGE 9   

 487   6                                                      if(GPRS_Buffer[orderIndex+2] == 'R')     //正常速度指令
 488   6                                                      {
 489   7                                                              UPLOAD_FREQ = 30;
 490   7                                                              //break;
 491   7                                                      }
 492   6                                                      else if(GPRS_Buffer[orderIndex+2] == 'H')        //高速指令
 493   6                                                      {
 494   7                                                              UPLOAD_FREQ = 10;;
 495   7                                                              //break;
 496   7                                                      }
 497   6                                              }
 498   5                                      }
 499   4                              }
 500   3      
 501   3                              clear_gprs_rev_buf();//清空缓存
 502   3                              EA = 1;
 503   3                      }
 504   2                      
 505   2              
 506   2                      if(voice == 1)          //蜂鸣器控制
 507   2                      {       
 508   3                              for(fmq=100;fmq>0;fmq--)
 509   3                              {
 510   4                                BEEP=~BEEP;       //输出频率1KHz
 511   4                                delay500us();       //延时500us
 512   4                              }
 513   3                      
 514   3                              for(fmq=100;fmq>0;fmq--)
 515   3                              {
 516   4                                BEEP=~BEEP;       //输出频率500Hz
 517   4                                delay500us();       //延时1ms
 518   4                                delay500us();
 519   4                              }
 520   3                      }
 521   2      
 522   2                      //delay(2000);
 523   2              }
 524   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1360    ----
   CONSTANT SIZE    =     87    ----
   XDATA SIZE       =    512    ----
   PDATA SIZE       =     13      10
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
