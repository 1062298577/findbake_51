C51 COMPILER V9.00   MAIN                                                                  05/13/2016 00:22:20 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c COMPACT ROM(COMPACT) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          /**
   2          **      FINDBAKE MAIN C FILE
   3          **
   4          **      TODO:
   5          **               run program at the first       
   6          **
   7          **      @luodongseu     github.com/luodongseu    2016/5/6
   8          **/
   9          
  10          //
  11          // 模块接口实现说明：
  12          //                                       串口1  P30,P31：GPRS模块（接收和发送数据）
  13          //                                       串口2  P42：GPS模块    （接收GPS数据）
  14          //
  15          // 功能说明：
  16          //                      GPS串口不断接收数据，存储到本地GPSINFO变量中
  17          //                      GPRS定时将GPSINFO变量中的数据发送到服务器中     
  18          //
  19          
  20          /*************** 用户定义参数 *****************************/
  21          
  22          #define MAIN_Fosc       22118400L       //define main clock
  23          
  24          #define Baudrate1       38400           //define the baudrate, 如果使用BRT做波特率发生器,则波特率跟串口2一样
  25                                                                                  //12T mode: 600~115200 for 22.1184MHZ, 300~57600 for 11.0592MHZ
  26          
  27          #define Baudrate2       9600            //define the baudrate2,
  28                                                                                  //12T mode: 600~115200 for 22.1184MHZ, 300~57600 for 11.0592MHZ
  29          
  30          #define BUF_LENTH       128                     //定义串口接收缓冲长度
  31          
  32          #define UPLOAD_FREQ     10                      //计数频率，单位秒
  33          
  34          /**********************************************************/
  35          
  36          #include        <reg51.h>
  37          #include        "GPS.h"
  38          #include        "GPRS.h"
  39          
  40          //#define uchar unsigned char;
  41          
  42          
  43          sfr AUXR1 = 0xA2;
  44          sfr     AUXR  = 0x8E;
  45          sfr S2CON = 0x9A;       //12C5A60S2双串口系列
  46          sfr S2BUF = 0x9B;       //12C5A60S2双串口系列
  47          sfr IE2   = 0xAF;       //STC12C5A60S2系列
  48          sfr BRT   = 0x9C;
  49          
  50          //串口1读写
  51          uchar   GPRS_wr;                //写指针
  52          uchar   GPRS_rd;                //读指针
  53          uchar   xdata GPRS_Buffer[BUF_LENTH];//接收缓存：
  54          bit             B_TI;                   //中断标志位
C51 COMPILER V9.00   MAIN                                                                  05/13/2016 00:22:20 PAGE 2   

  55          uchar   GPRS_Listening; //启动成功后监听
  56          
  57          
  58          //串口2读写
  59          uchar   GPS_wr = 0;             //写指针
  60          uchar   GPS_rd = 0;             //读指针
  61          uchar   xdata GPS_Buffer[BUF_LENTH];//接收缓存  [0]表示写允许位 [1]表示读允许位
  62          unsigned int    gps_rev_start = 0;//接收标志
  63          
  64          
  65          uchar   count = 0;              //计数
  66          
  67          uchar   xdata   datas[80] = "GET /?gps=0000.0000,0000.0000 HTTP/1.1\r\nHost:www.luodongseu.top\r\n\r\n\r\n";
  68          
  69          /****************** 编译器自动生成，用户请勿修改 ************************************/
  70          
  71          #define T1_TimerReload  (256 - MAIN_Fosc / 192 / Baudrate1)                     //Calculate the timer1 reload value     at 12T mo
             -de
  72          #define BRT_Reload              (256 - MAIN_Fosc / 12 / 16 / Baudrate2)         //Calculate BRT reload value
  73          
  74          #define TimeOut1                (28800 / (unsigned long)Baudrate1 + 2)
  75          #define TimeOut2                (28800 / (unsigned long)Baudrate2 + 2)
  76          
  77          #define TI2                             (S2CON & 0x02) != 0
  78          #define RI2                             (S2CON & 0x01) != 0
  79          #define CLR_TI2()               S2CON &= ~0x02
  80          #define CLR_RI2()               S2CON &= ~0x01
  81          
  82          /**********************************************************/
  83          
  84          
  85          //GPRS串口初始化
  86          void    GPRS_init(void)
  87          {
  88   1              TMOD = 0x20;    //定时器1工作在方式2  8位自动重装
  89   1              //PCON |= 0x80;         //UART0 Double Rate Enable
  90   1              SCON = 0x50;            //UART0 set as 10bit , UART0 RX enable
  91   1              //TMOD &= ~(1<<6);              //Timer1 Set as Timer, 12T
  92   1              //TMOD = (TMOD & ~0x30) | 0x20; //Timer1 set as 8 bits auto relaod
  93   1              TH1 = T1_TimerReload;           //Load the timer
  94   1              TL1 = TH1;
  95   1              TR1  = 1;
  96   1              ES  = 1;
  97   1              EA = 1;
  98   1      }                                                                                                        
  99          
 100          //GPS串口初始化
 101          void    GPS_init(void)
 102          {
 103   1              AUXR1 |= (1<<4);        //将UART2从P1口切换到 RXD2--P1.2切换到P4.2   TXD2---P1.3切换到P4.3
 104   1              AUXR |=  (1 << 3);              //串口2波特率加倍
 105   1              S2CON  = (S2CON & 0x3f) | (1<<6);       //串口2模式1，8位UART，(2^S2SMOD / 32) * BRT溢出率
 106   1              S2CON |= 1 << 4;                //允许串2接收
 107   1              //S2CON = 0x50;   //串口2工作在方式1  10位异步收发 S2REN=1允许接收
 108   1      
 109   1              AUXR |=  1 << 4;        //baudrate use BRT
 110   1              BRT = BRT_Reload;
 111   1      
 112   1              IE2 |=  1;                      //允许串口2中断
 113   1      }
 114          
 115          
C51 COMPILER V9.00   MAIN                                                                  05/13/2016 00:22:20 PAGE 3   

 116          ////GPRS口发送数据
 117          //void  GPRS_TxByte(uchar dat)
 118          //{
 119          //      SBUF = dat;             //将接收的数据发送回去
 120          //      while(TI == 0); //检查发送中断标志位
 121          //      TI = 0;                 //令发送中断标志位为0（软件清零）
 122          //}
 123          //
 124          ////GPRS口发送一串字符串
 125          //void GPRS_TxString(uchar code *puts)          
 126          //{
 127          //    for (; *puts != 0;        puts++)  GPRS_TxByte(*puts);    //遇到停止符0结束
 128          //}
 129          
 130          //GPS输出口发送数据 用于调试数据
 131          void Test_TxByte(uchar c)
 132          {
 133   1              S2BUF = c;
 134   1              while(TI2);
 135   1              CLR_TI2();
 136   1      }
 137          
 138          //GPS口发送一串字符串
 139          void Test_TxString(uchar *puts)         
 140          {
 141   1          for (; *puts != '\0';       puts++)  GPS_TxByte(*puts);     //遇到停止符0结束
 142   1      }
 143          
 144          //清除GPRS接收数据缓存
 145          void clear_gprs_rev_buf()
 146          {
 147   1              uchar index=0;
 148   1               
 149   1              for(index = 0 ; index < BUF_LENTH ; index++)
 150   1              {
 151   2                      GPRS_Buffer[index]='\0';
 152   2              }
 153   1      
 154   1              GPRS_Buffer[0] = 2;             //允许写位
 155   1              GPRS_Buffer[1] = 2;             //允许读位
 156   1              GPRS_wr = 0;                    //写指针位
 157   1      }
 158          
 159          //清除GPS接收数据缓存
 160          void clear_gps_rev_buf()
 161          {
 162   1              uchar index=0;
 163   1               
 164   1              for(index = 0 ; index < BUF_LENTH ; index++)
 165   1              {
 166   2                      GPS_Buffer[index]='\0';
 167   2              }
 168   1      
 169   1              GPS_Buffer[0] = 2;              //允许写位
 170   1              GPS_Buffer[1] = 2;              //允许读位
 171   1              GPS_wr = 0;                     //写指针位
 172   1              gps_rev_start = 0;      
 173   1      }
 174          
 175          /**
 176          串口1中断响应
 177          *************
C51 COMPILER V9.00   MAIN                                                                  05/13/2016 00:22:20 PAGE 4   

 178          接收GPRS数据
 179          *************
 180          对应--GPRS模块
 181          *************
 182          **/
 183          void    GPRS_RCV (void) interrupt 4
 184          {
 185   1              uchar ch;
 186   1              if(RI)
 187   1              {
 188   2                      //EA = 0;       //暂停中断
 189   2                      RI = 0; //复位
 190   2      
 191   2                      
 192   2                      ch = SBUF;
 193   2      
 194   2                      //GPS_TxString("gprs rev");
 195   2                      if(GPRS_Listening != 1)    //GPRS在初始化中,将中断数据返回给GPRS
 196   2                      {
 197   3                              setRevBuf(ch);  
 198   3                      }
 199   2                      else
 200   2                      {
 201   3                              if(ch == '{')  // 服务器返回有效数据起始位为'{'
 202   3                              {
 203   4                                      GPRS_Buffer[0] = 1;     //数据缓存允许位置1，表示允许接收
 204   4                                      GPRS_Buffer[1] = 2;     //数据缓存可读位置2，表示数据不可读
 205   4                                      GPRS_wr = 0;            
 206   4                              }
 207   3                              else if (GPRS_Buffer[0] == 1 && ch == '}') //服务器返回有效数据结束位为'}'
 208   3                              {
 209   4                                      GPRS_Buffer[1] = 1;             //数据缓存可读位置1，表示数据可读               
 210   4                              }
 211   3                              else if (GPRS_Buffer[0] == 1)
 212   3                              {
 213   4                                      if(++GPRS_wr < BUF_LENTH -1)            //防止数据溢出
 214   4                                      {
 215   5                                              GPRS_Buffer[GPRS_wr] = ch;
 216   5                                      }
 217   4                                      else
 218   4                                      {
 219   5                                              clear_gprs_rev_buf();
 220   5                                      }
 221   4                                      
 222   4                              }
 223   3                              else    //无效数据
 224   3                              {
 225   4                                      clear_gprs_rev_buf();
 226   4                              }       
 227   3                      }
 228   2      
 229   2                      //EA = 1;       //打开中断
 230   2              }
 231   1      }
 232          uchar a[5] = "abc\n";
 233          /**
 234          串口1中断响应
 235          *************
 236          接收GPS数据
 237          *************
 238          对应--GPS模块 只解析GPRMC数据
 239          *************
C51 COMPILER V9.00   MAIN                                                                  05/13/2016 00:22:20 PAGE 5   

 240          **/
 241          void GPS_RCV (void) interrupt 8
 242          {
 243   1              uchar ch;
 244   1              
 245   1              if(!RI2)
 246   1              {
 247   2                      return;
 248   2              }
 249   1      
 250   1              if(GPRS_Listening != 1 ) //只有当计数为最大值时，且处于监听状态才可以读取数据
 251   1              {
 252   2                      CLR_RI2();
 253   2                      return;
 254   2              }
 255   1      
 256   1              ch=S2BUF;
 257   1      
 258   1              if (gps_rev_start == 0 && ch == '$')  //如果收到字符'$' 标志为1
 259   1              {
 260   2                      gps_rev_start = 1;
 261   2              }       
 262   1              else if (gps_rev_start == 1 && ch == 'G') //如果 标志位为1,收到字符'G'，判断第2位
 263   1              {
 264   2                      gps_rev_start = 2;                      
 265   2              }
 266   1              else if (gps_rev_start == 2 && ch == 'P')  //如果 标志位为2,收到字符'P'，判断第3位
 267   1              {
 268   2                      gps_rev_start = 3;
 269   2              }
 270   1              else if (gps_rev_start == 3 && ch == 'R')  //如果 标志位为3,收到字符'R'，判断第4位
 271   1              {
 272   2                      gps_rev_start = 4;
 273   2              }
 274   1              else if (gps_rev_start == 4 && ch == 'M')  //如果 标志位为4,收到字符'M'，判断第5位
 275   1              {
 276   2                      gps_rev_start = 5;
 277   2              }
 278   1              else if (gps_rev_start == 5 && ch == 'C')  //如果 标志位为5,收到字符'C'，判断第6位
 279   1              {
 280   2                      gps_rev_start = 6;
 281   2              }
 282   1              else if (gps_rev_start == 6 && ch == ',')  //如果 标志位为6,收到字符','，开始接收数据
 283   1              {
 284   2                      gps_rev_start = 7;
 285   2                      GPS_wr = 2;
 286   2                      GPS_Buffer[1]=2;
 287   2                      GPS_Buffer[0]=1;
 288   2              }
 289   1              else if(gps_rev_start >= 1 && gps_rev_start < 7)
 290   1              {
 291   2                      gps_rev_start = 0;      
 292   2              }
 293   1      
 294   1              if(gps_rev_start == 7 && GPS_Buffer[1] != 1)
 295   1              {
 296   2      
 297   2                      if (ch == '\n')     //如果接收到换行
 298   2                      {
 299   3                              count = count + 1;
 300   3                              gps_rev_start = 0;
 301   3                              //Test_TxString("GO END\n");
C51 COMPILER V9.00   MAIN                                                                  05/13/2016 00:22:20 PAGE 6   

 302   3                              if(count == UPLOAD_FREQ + 1) // 当计数等于count+1 的时候才记录数据,让等于10的时候记录数据
 303   3                              {
 304   4                                      Test_TxString("GOT A END\n");           
 305   4                                      GPS_Buffer[0]=2; //close present write
 306   4                                      GPS_Buffer[1]=1; //open prensnt read 
 307   4                                      count = 0;
 308   4                                      delay(1000);
 309   4                              }                       
 310   3                      }
 311   2                      else
 312   2                      {                               
 313   3                              if(count == UPLOAD_FREQ && GPS_Buffer[0] == 1)//可写
 314   3                              {
 315   4                                 GPS_Buffer[GPS_wr] = ch;  //字符存到数组中
 316   4                                      GPS_wr = GPS_wr + 1;
 317   4      //                              Test_TxString("GOT:");
 318   4      //                              a[0] = GPS_wr + '0';
 319   4      //                              Test_TxString(&GPS_Buffer[2]);
 320   4      //                      
 321   4      //                              Test_TxString("\n");
 322   4      //                              Test_TxString(a);
 323   4                              }                               
 324   3                      }
 325   2                              
 326   2              }
 327   1              CLR_RI2();
 328   1      }
 329          
 330          //入口主函数
 331          void main(){
 332   1              GPRS_wr = 0;
 333   1              GPS_wr = 0;
 334   1              GPRS_Listening = 0;
 335   1              
 336   1              clear_gps_rev_buf();
 337   1              clear_gprs_rev_buf();
 338   1              
 339   1              GPS_init();
 340   1              GPRS_init();
 341   1      
 342   1              Test_TxString("main____\0");
 343   1              gprs_start();                                   //启动GPRS初始化功能
 344   1      
 345   1              Test_TxString("main start listenning\n");
 346   1              
 347   1              GPRS_Listening = 1;                             //开始监听网络传输数据
 348   1      
 349   1              //EA = 0;
 350   1              while(1)
 351   1              {
 352   2                      
 353   2                      //除了GPS数据
 354   2                      if(GPS_Buffer[1] == 1)  //GPS数据可读时操作
 355   2                      {
 356   3                              Test_TxString("GPS Buffer:");
 357   3                              Test_TxString(&GPS_Buffer[2]);
 358   3                              Test_TxString("\n");
 359   3                              /**
 360   3                              **[13]-定位结果状态V/A
 361   3                              **[15-23]-纬度 ddmm.mmmm
 362   3                              **[27-35]-经度 ddmm.mmmm
 363   3                              **/
C51 COMPILER V9.00   MAIN                                                                  05/13/2016 00:22:20 PAGE 7   

 364   3                              if(GPS_Buffer[13] != 'A')
 365   3                              {
 366   4                                      //定位失败,发送-1               
 367   4                                      sendData("GET /?data=-1 HTTP/1.1\r\nHost:www.luodongseu.top\r\n\r\n\r\n");
 368   4                              }
 369   3                              else
 370   3                              {
 371   4                                      //填充真实坐标数据
 372   4                                      datas[10]=GPS_Buffer[15];                                       
 373   4                                      datas[11]=GPS_Buffer[16];
 374   4                                      datas[12]=GPS_Buffer[17];
 375   4                                      datas[13]=GPS_Buffer[18];
 376   4                                      datas[14]=GPS_Buffer[19];
 377   4                                      datas[15]=GPS_Buffer[20];
 378   4                                      datas[16]=GPS_Buffer[21];
 379   4                                      datas[17]=GPS_Buffer[22];
 380   4                                      datas[18]=GPS_Buffer[23];
 381   4                                      datas[19]=",";
*** WARNING C260 IN LINE 381 OF MAIN.C: '=': pointer truncation
 382   4                                      datas[20]=GPS_Buffer[27];
 383   4                                      datas[21]=GPS_Buffer[28];
 384   4                                      datas[22]=GPS_Buffer[29];
 385   4                                      datas[23]=GPS_Buffer[30];
 386   4                                      datas[24]=GPS_Buffer[31];
 387   4                                      datas[25]=GPS_Buffer[32];
 388   4                                      datas[26]=GPS_Buffer[33];
 389   4                                      datas[27]=GPS_Buffer[34];
 390   4                                      datas[28]=GPS_Buffer[35];
 391   4      
 392   4                                      sendData(datas);
 393   4                              }
 394   3                              clear_gps_rev_buf();
 395   3                      }
 396   2                      //处理GPRS接收的数据
 397   2                      if(GPRS_Buffer[1] == 1)  //GPRS收到服务器返回的数据
 398   2                      {
 399   3                              Test_TxString("GPRS Buffer:");
 400   3                              Test_TxString(&GPRS_Buffer[2]);
 401   3                              Test_TxString("\n");
 402   3                              clear_gprs_rev_buf();
 403   3                      }
 404   2                      //delay(2000);
 405   2              }
 406   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1021    ----
   CONSTANT SIZE    =    127    ----
   XDATA SIZE       =    336    ----
   PDATA SIZE       =     13       5
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
